{% doc %}
  @prompt
    a section to display the 3d box which can be rotated having orbit control feature, a real 3d box
{% enddoc %}
{% assign ai_gen_id = block.id | replace: '_', '' | downcase %}

{% style %}
  .ai-3d-box-container-{{ ai_gen_id }} {
    width: 100%;
    max-width: {{ block.settings.container_width }}px;
    margin: 0 auto;
    padding: {{ block.settings.container_padding }}px;
    background-color: {{ block.settings.background_color }};
    border-radius: {{ block.settings.border_radius }}px;
  }

  .ai-3d-box-canvas-{{ ai_gen_id }} {
    width: 100%;
    height: {{ block.settings.canvas_height }}px;
    border: {{ block.settings.border_width }}px solid {{ block.settings.border_color }};
    border-radius: {{ block.settings.canvas_border_radius }}px;
    cursor: grab;
    display: block;
    background: {{ block.settings.canvas_background }};
  }

  .ai-3d-box-canvas-{{ ai_gen_id }}:active {
    cursor: grabbing;
  }

  .ai-3d-box-controls-{{ ai_gen_id }} {
    display: flex;
    justify-content: center;
    gap: 10px;
    margin-top: 15px;
    flex-wrap: wrap;
  }

  .ai-3d-box-button-{{ ai_gen_id }} {
    padding: 8px 16px;
    background-color: {{ block.settings.button_color }};
    color: {{ block.settings.button_text_color }};
    border: none;
    border-radius: {{ block.settings.button_border_radius }}px;
    cursor: pointer;
    font-size: 14px;
    transition: background-color 0.3s ease;
  }

  .ai-3d-box-button-{{ ai_gen_id }}:hover {
    background-color: {{ block.settings.button_hover_color }};
  }

  .ai-3d-box-button-{{ ai_gen_id }}.active {
    background-color: {{ block.settings.button_active_color }};
  }

  .ai-3d-box-info-{{ ai_gen_id }} {
    text-align: center;
    margin-top: 10px;
    font-size: 14px;
    color: {{ block.settings.text_color }};
  }

  @media screen and (max-width: 768px) {
    .ai-3d-box-canvas-{{ ai_gen_id }} {
      height: {{ block.settings.canvas_height | times: 0.7 }}px;
    }
    
    .ai-3d-box-container-{{ ai_gen_id }} {
      padding: {{ block.settings.container_padding | times: 0.7 }}px;
    }
  }
{% endstyle %}

<real-3d-box-{{ ai_gen_id }} class="ai-3d-box-container-{{ ai_gen_id }}" {{ block.shopify_attributes }}>
  <canvas class="ai-3d-box-canvas-{{ ai_gen_id }}" id="ai-3d-box-canvas-{{ ai_gen_id }}"></canvas>
  
  <div class="ai-3d-box-controls-{{ ai_gen_id }}">
    <button class="ai-3d-box-button-{{ ai_gen_id }}" id="ai-3d-box-reset-{{ ai_gen_id }}">Reset View</button>
    <button class="ai-3d-box-button-{{ ai_gen_id }}" id="ai-3d-box-wireframe-{{ ai_gen_id }}">Toggle Wireframe</button>
    <button class="ai-3d-box-button-{{ ai_gen_id }}" id="ai-3d-box-auto-rotate-{{ ai_gen_id }}">Auto Rotate</button>
  </div>
  
  <div class="ai-3d-box-info-{{ ai_gen_id }}">
    Drag to rotate • Scroll to zoom • Touch and drag on mobile
  </div>
</real-3d-box-{{ ai_gen_id }}>

<script>
(function() {
  class Real3DBox{{ ai_gen_id }} extends HTMLElement {
    constructor() {
      super();
      this.canvas = null;
      this.gl = null;
      this.program = null;
      this.buffers = {};
      this.uniforms = {};
      this.rotation = { x: 0.3, y: 0.3 };
      this.zoom = 3.0;
      this.isDragging = false;
      this.lastMouse = { x: 0, y: 0 };
      this.autoRotate = false;
      this.wireframe = false;
      this.animationId = null;
    }

    connectedCallback() {
      this.canvas = this.querySelector('#ai-3d-box-canvas-{{ ai_gen_id }}');
      this.setupWebGL();
      this.setupEventListeners();
      this.render();
    }

    disconnectedCallback() {
      if (this.animationId) {
        cancelAnimationFrame(this.animationId);
      }
    }

    setupWebGL() {
      this.gl = this.canvas.getContext('webgl') || this.canvas.getContext('experimental-webgl');
      
      if (!this.gl) {
        this.canvas.innerHTML = 'WebGL not supported';
        return;
      }

      this.resizeCanvas();
      
      const vertexShaderSource = `
        attribute vec3 aPosition;
        attribute vec3 aNormal;
        attribute vec3 aColor;
        
        uniform mat4 uModelViewMatrix;
        uniform mat4 uProjectionMatrix;
        uniform mat3 uNormalMatrix;
        
        varying vec3 vColor;
        varying vec3 vNormal;
        varying vec3 vPosition;
        
        void main() {
          vec4 position = uModelViewMatrix * vec4(aPosition, 1.0);
          gl_Position = uProjectionMatrix * position;
          
          vColor = aColor;
          vNormal = normalize(uNormalMatrix * aNormal);
          vPosition = position.xyz;
        }
      `;

      const fragmentShaderSource = `
        precision mediump float;
        
        varying vec3 vColor;
        varying vec3 vNormal;
        varying vec3 vPosition;
        
        uniform vec3 uLightDirection;
        uniform bool uWireframe;
        
        void main() {
          if (uWireframe) {
            gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
          } else {
            float light = max(dot(normalize(vNormal), normalize(uLightDirection)), 0.3);
            gl_FragColor = vec4(vColor * light, 1.0);
          }
        }
      `;

      this.program = this.createShaderProgram(vertexShaderSource, fragmentShaderSource);
      this.gl.useProgram(this.program);

      this.setupBuffers();
      this.setupUniforms();
      
      this.gl.enable(this.gl.DEPTH_TEST);
      this.gl.enable(this.gl.CULL_FACE);
      this.gl.clearColor(0.1, 0.1, 0.1, 1.0);
    }

    createShaderProgram(vertexSource, fragmentSource) {
      const vertexShader = this.createShader(this.gl.VERTEX_SHADER, vertexSource);
      const fragmentShader = this.createShader(this.gl.FRAGMENT_SHADER, fragmentSource);
      
      const program = this.gl.createProgram();
      this.gl.attachShader(program, vertexShader);
      this.gl.attachShader(program, fragmentShader);
      this.gl.linkProgram(program);
      
      if (!this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {
        console.error('Program link error:', this.gl.getProgramInfoLog(program));
        return null;
      }
      
      return program;
    }

    createShader(type, source) {
      const shader = this.gl.createShader(type);
      this.gl.shaderSource(shader, source);
      this.gl.compileShader(shader);
      
      if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
        console.error('Shader compile error:', this.gl.getShaderInfoLog(shader));
        this.gl.deleteShader(shader);
        return null;
      }
      
      return shader;
    }

    setupBuffers() {
      const vertices = new Float32Array([
        -1, -1,  1,  1, -1,  1,  1,  1,  1, -1,  1,  1,
        -1, -1, -1, -1,  1, -1,  1,  1, -1,  1, -1, -1,
        -1,  1, -1, -1,  1,  1,  1,  1,  1,  1,  1, -1,
        -1, -1, -1,  1, -1, -1,  1, -1,  1, -1, -1,  1,
         1, -1, -1,  1,  1, -1,  1,  1,  1,  1, -1,  1,
        -1, -1, -1, -1, -1,  1, -1,  1,  1, -1,  1, -1
      ]);

      const normals = new Float32Array([
         0,  0,  1,  0,  0,  1,  0,  0,  1,  0,  0,  1,
         0,  0, -1,  0,  0, -1,  0,  0, -1,  0,  0, -1,
         0,  1,  0,  0,  1,  0,  0,  1,  0,  0,  1,  0,
         0, -1,  0,  0, -1,  0,  0, -1,  0,  0, -1,  0,
         1,  0,  0,  1,  0,  0,  1,  0,  0,  1,  0,  0,
        -1,  0,  0, -1,  0,  0, -1,  0,  0, -1,  0,  0
      ]);

      const colors = new Float32Array([
        1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0,
        0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0,
        0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1,
        1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0,
        1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1,
        0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1
      ]);

      const indices = new Uint16Array([
         0,  1,  2,   0,  2,  3,
         4,  5,  6,   4,  6,  7,
         8,  9, 10,   8, 10, 11,
        12, 13, 14,  12, 14, 15,
        16, 17, 18,  16, 18, 19,
        20, 21, 22,  20, 22, 23
      ]);

      this.buffers.position = this.gl.createBuffer();
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffers.position);
      this.gl.bufferData(this.gl.ARRAY_BUFFER, vertices, this.gl.STATIC_DRAW);

      this.buffers.normal = this.gl.createBuffer();
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffers.normal);
      this.gl.bufferData(this.gl.ARRAY_BUFFER, normals, this.gl.STATIC_DRAW);

      this.buffers.color = this.gl.createBuffer();
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffers.color);
      this.gl.bufferData(this.gl.ARRAY_BUFFER, colors, this.gl.STATIC_DRAW);

      this.buffers.indices = this.gl.createBuffer();
      this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.buffers.indices);
      this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, indices, this.gl.STATIC_DRAW);
    }

    setupUniforms() {
      this.uniforms.modelViewMatrix = this.gl.getUniformLocation(this.program, 'uModelViewMatrix');
      this.uniforms.projectionMatrix = this.gl.getUniformLocation(this.program, 'uProjectionMatrix');
      this.uniforms.normalMatrix = this.gl.getUniformLocation(this.program, 'uNormalMatrix');
      this.uniforms.lightDirection = this.gl.getUniformLocation(this.program, 'uLightDirection');
      this.uniforms.wireframe = this.gl.getUniformLocation(this.program, 'uWireframe');

      this.attributes = {
        position: this.gl.getAttribLocation(this.program, 'aPosition'),
        normal: this.gl.getAttribLocation(this.program, 'aNormal'),
        color: this.gl.getAttribLocation(this.program, 'aColor')
      };
    }

    setupEventListeners() {
      const resetBtn = this.querySelector('#ai-3d-box-reset-{{ ai_gen_id }}');
      const wireframeBtn = this.querySelector('#ai-3d-box-wireframe-{{ ai_gen_id }}');
      const autoRotateBtn = this.querySelector('#ai-3d-box-auto-rotate-{{ ai_gen_id }}');

      resetBtn.addEventListener('click', () => this.resetView());
      wireframeBtn.addEventListener('click', () => this.toggleWireframe());
      autoRotateBtn.addEventListener('click', () => this.toggleAutoRotate());

      this.canvas.addEventListener('mousedown', (e) => this.onMouseDown(e));
      this.canvas.addEventListener('mousemove', (e) => this.onMouseMove(e));
      this.canvas.addEventListener('mouseup', () => this.onMouseUp());
      this.canvas.addEventListener('wheel', (e) => this.onWheel(e));

      this.canvas.addEventListener('touchstart', (e) => this.onTouchStart(e));
      this.canvas.addEventListener('touchmove', (e) => this.onTouchMove(e));
      this.canvas.addEventListener('touchend', () => this.onTouchEnd());

      window.addEventListener('resize', () => this.resizeCanvas());
    }

    onMouseDown(e) {
      this.isDragging = true;
      this.lastMouse = { x: e.clientX, y: e.clientY };
    }

    onMouseMove(e) {
      if (!this.isDragging) return;
      
      const deltaX = e.clientX - this.lastMouse.x;
      const deltaY = e.clientY - this.lastMouse.y;
      
      this.rotation.y += deltaX * 0.01;
      this.rotation.x += deltaY * 0.01;
      
      this.lastMouse = { x: e.clientX, y: e.clientY };
    }

    onMouseUp() {
      this.isDragging = false;
    }

    onTouchStart(e) {
      e.preventDefault();
      if (e.touches.length === 1) {
        this.isDragging = true;
        this.lastMouse = { x: e.touches[0].clientX, y: e.touches[0].clientY };
      }
    }

    onTouchMove(e) {
      e.preventDefault();
      if (!this.isDragging || e.touches.length !== 1) return;
      
      const deltaX = e.touches[0].clientX - this.lastMouse.x;
      const deltaY = e.touches[0].clientY - this.lastMouse.y;
      
      this.rotation.y += deltaX * 0.01;
      this.rotation.x += deltaY * 0.01;
      
      this.lastMouse = { x: e.touches[0].clientX, y: e.touches[0].clientY };
    }

    onTouchEnd() {
      this.isDragging = false;
    }

    onWheel(e) {
      e.preventDefault();
      this.zoom += e.deltaY * 0.01;
      this.zoom = Math.max(1.5, Math.min(8.0, this.zoom));
    }

    resetView() {
      this.rotation = { x: 0.3, y: 0.3 };
      this.zoom = 3.0;
    }

    toggleWireframe() {
      this.wireframe = !this.wireframe;
      const btn = this.querySelector('#ai-3d-box-wireframe-{{ ai_gen_id }}');
      btn.classList.toggle('active', this.wireframe);
    }

    toggleAutoRotate() {
      this.autoRotate = !this.autoRotate;
      const btn = this.querySelector('#ai-3d-box-auto-rotate-{{ ai_gen_id }}');
      btn.classList.toggle('active', this.autoRotate);
    }

    resizeCanvas() {
      const rect = this.canvas.getBoundingClientRect();
      this.canvas.width = rect.width * window.devicePixelRatio;
      this.canvas.height = rect.height * window.devicePixelRatio;
      this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
    }

    createMatrix4() {
      return new Float32Array(16);
    }

    identity(matrix) {
      matrix.fill(0);
      matrix[0] = matrix[5] = matrix[10] = matrix[15] = 1;
      return matrix;
    }

    perspective(matrix, fovy, aspect, near, far) {
      const f = 1.0 / Math.tan(fovy / 2);
      const nf = 1 / (near - far);
      
      this.identity(matrix);
      matrix[0] = f / aspect;
      matrix[5] = f;
      matrix[10] = (far + near) * nf;
      matrix[11] = -1;
      matrix[14] = 2 * far * near * nf;
      matrix[15] = 0;
      
      return matrix;
    }

    translate(matrix, x, y, z) {
      matrix[12] += matrix[0] * x + matrix[4] * y + matrix[8] * z;
      matrix[13] += matrix[1] * x + matrix[5] * y + matrix[9] * z;
      matrix[14] += matrix[2] * x + matrix[6] * y + matrix[10] * z;
      matrix[15] += matrix[3] * x + matrix[7] * y + matrix[11] * z;
      return matrix;
    }

    rotateX(matrix, angle) {
      const c = Math.cos(angle);
      const s = Math.sin(angle);
      const mv1 = matrix[1], mv5 = matrix[5], mv9 = matrix[9];
      
      matrix[1] = matrix[1] * c - matrix[2] * s;
      matrix[5] = matrix[5] * c - matrix[6] * s;
      matrix[9] = matrix[9] * c - matrix[10] * s;
      
      matrix[2] = matrix[2] * c + mv1 * s;
      matrix[6] = matrix[6] * c + mv5 * s;
      matrix[10] = matrix[10] * c + mv9 * s;
      
      return matrix;
    }

    rotateY(matrix, angle) {
      const c = Math.cos(angle);
      const s = Math.sin(angle);
      const mv0 = matrix[0], mv4 = matrix[4], mv8 = matrix[8];
      
      matrix[0] = c * matrix[0] + s * matrix[2];
      matrix[4] = c * matrix[4] + s * matrix[6];
      matrix[8] = c * matrix[8] + s * matrix[10];
      
      matrix[2] = c * matrix[2] - s * mv0;
      matrix[6] = c * matrix[6] - s * mv4;
      matrix[10] = c * matrix[10] - s * mv8;
      
      return matrix;
    }

    render() {
      if (!this.gl) return;

      if (this.autoRotate) {
        this.rotation.y += 0.01;
      }

      this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);

      const projectionMatrix = this.createMatrix4();
      const modelViewMatrix = this.createMatrix4();
      
      this.perspective(projectionMatrix, Math.PI / 4, this.canvas.width / this.canvas.height, 0.1, 100.0);
      this.identity(modelViewMatrix);
      this.translate(modelViewMatrix, 0, 0, -this.zoom);
      this.rotateX(modelViewMatrix, this.rotation.x);
      this.rotateY(modelViewMatrix, this.rotation.y);

      this.gl.uniformMatrix4fv(this.uniforms.projectionMatrix, false, projectionMatrix);
      this.gl.uniformMatrix4fv(this.uniforms.modelViewMatrix, false, modelViewMatrix);
      
      const normalMatrix = new Float32Array([
        modelViewMatrix[0], modelViewMatrix[1], modelViewMatrix[2],
        modelViewMatrix[4], modelViewMatrix[5], modelViewMatrix[6],
        modelViewMatrix[8], modelViewMatrix[9], modelViewMatrix[10]
      ]);
      this.gl.uniformMatrix3fv(this.uniforms.normalMatrix, false, normalMatrix);
      
      this.gl.uniform3f(this.uniforms.lightDirection, 0.5, 0.7, 1.0);
      this.gl.uniform1i(this.uniforms.wireframe, this.wireframe);

      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffers.position);
      this.gl.vertexAttribPointer(this.attributes.position, 3, this.gl.FLOAT, false, 0, 0);
      this.gl.enableVertexAttribArray(this.attributes.position);

      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffers.normal);
      this.gl.vertexAttribPointer(this.attributes.normal, 3, this.gl.FLOAT, false, 0, 0);
      this.gl.enableVertexAttribArray(this.attributes.normal);

      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffers.color);
      this.gl.vertexAttribPointer(this.attributes.color, 3, this.gl.FLOAT, false, 0, 0);
      this.gl.enableVertexAttribArray(this.attributes.color);

      this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.buffers.indices);

      if (this.wireframe) {
        for (let i = 0; i < 36; i += 3) {
          this.gl.drawElements(this.gl.LINE_LOOP, 3, this.gl.UNSIGNED_SHORT, i * 2);
        }
      } else {
        this.gl.drawElements(this.gl.TRIANGLES, 36, this.gl.UNSIGNED_SHORT, 0);
      }

      this.animationId = requestAnimationFrame(() => this.render());
    }
  }

  customElements.define('real-3d-box-{{ ai_gen_id }}', Real3DBox{{ ai_gen_id }});
})();
</script>

{% schema %}
{
  "name": "Real 3D Box",
  "settings": [
    {
      "type": "header",
      "content": "Container"
    },
    {
      "type": "range",
      "id": "container_width",
      "min": 300,
      "max": 1000,
      "step": 50,
      "unit": "px",
      "label": "Container width",
      "default": 600
    },
    {
      "type": "range",
      "id": "container_padding",
      "min": 10,
      "max": 50,
      "step": 5,
      "unit": "px",
      "label": "Container padding",
      "default": 20
    },
    {
      "type": "color",
      "id": "background_color",
      "label": "Background color",
      "default": "#f8f8f8"
    },
    {
      "type": "range",
      "id": "border_radius",
      "min": 0,
      "max": 20,
      "step": 2,
      "unit": "px",
      "label": "Border radius",
      "default": 8
    },
    {
      "type": "header",
      "content": "Canvas"
    },
    {
      "type": "range",
      "id": "canvas_height",
      "min": 300,
      "max": 800,
      "step": 50,
      "unit": "px",
      "label": "Canvas height",
      "default": 500
    },
    {
      "type": "color",
      "id": "canvas_background",
      "label": "Canvas background",
      "default": "#1a1a1a"
    },
    {
      "type": "range",
      "id": "border_width",
      "min": 0,
      "max": 5,
      "step": 1,
      "unit": "px",
      "label": "Canvas border width",
      "default": 2
    },
    {
      "type": "color",
      "id": "border_color",
      "label": "Canvas border color",
      "default": "#333333"
    },
    {
      "type": "range",
      "id": "canvas_border_radius",
      "min": 0,
      "max": 15,
      "step": 1,
      "unit": "px",
      "label": "Canvas border radius",
      "default": 4
    },
    {
      "type": "header",
      "content": "Controls"
    },
    {
      "type": "color",
      "id": "button_color",
      "label": "Button color",
      "default": "#007acc"
    },
    {
      "type": "color",
      "id": "button_text_color",
      "label": "Button text color",
      "default": "#ffffff"
    },
    {
      "type": "color",
      "id": "button_hover_color",
      "label": "Button hover color",
      "default": "#005a99"
    },
    {
      "type": "color",
      "id": "button_active_color",
      "label": "Button active color",
      "default": "#ff6b35"
    },
    {
      "type": "range",
      "id": "button_border_radius",
      "min": 0,
      "max": 15,
      "step": 1,
      "unit": "px",
      "label": "Button border radius",
      "default": 4
    },
    {
      "type": "color",
      "id": "text_color",
      "label": "Text color",
      "default": "#666666"
    }
  ],
  "presets": [
    {
      "name": "Real 3D Box"
    }
  ]
}
{% endschema %}