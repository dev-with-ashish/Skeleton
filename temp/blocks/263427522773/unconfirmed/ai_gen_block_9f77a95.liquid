{% doc %}
  @prompt
    a section to display the 3d box which can be rotated having orbit control feature, a real 3d box, nox 3d box is showing, now make it a 2:3 in ratio, make it a poster 1 mm poster of 2:3 in ratio, why there is a split in the poster seems like poster is made from four poster remove the extra lines and split from the scene just a 1mm metal poster, there is still lines on top and left or right and in the centre of the poster remove all that extra line , let the front image of the poster to be the last imge of a selected product or last image of the product if it is on a product page, in the left of the container show the thumbnail column to display the product images expect the last image with option to display image in the container when image is clicked from the thumbnail column and this 3d poster as it is right now when 3d button is clicked from the thumbnail column and in the right side of the container show the product information keep the container and poster as it is when 3d button is clicked from the thumbnail column , in the left of the container show the thumbnail column to display the product images expect the last image, the thumbnail and the info should be shown outside the main container, main container should always be in square shape, poster should be inside the squared container in the center and responsive to the container, irrespective of the device container should always in square and the poster fixed in the center of the container responsive in size to the container maintaing 2:3 ratio, evrything all right just fix why product images except the last image not showing on in the thumbnail column, the product info should display product variant like size and material in button siyle in one responsive hozontal line always, when acrylic is clicked from the product variant the poster should have glossy finish and when metal is clicked it should have matt finish, keep everything same just add this feature when acrylic is clicked from the product variant : add an extra transparent layer so the poster apper glossy and make poster 3mm thick, add studio three lighting setup, why the poster is not lighted up why it is dark
{% enddoc %}
{% assign ai_gen_id = block.id | replace: '_', '' | downcase %}

{% style %}
  .ai-product-viewer-{{ ai_gen_id }} {
    display: flex;
    gap: 20px;
    max-width: 100%;
    margin: 0 auto;
    padding: 20px;
  }

  .ai-thumbnail-column-{{ ai_gen_id }} {
    display: flex;
    flex-direction: column;
    gap: 10px;
    width: 80px;
    flex-shrink: 0;
  }

  .ai-thumbnail-{{ ai_gen_id }} {
    width: 80px;
    height: 80px;
    border: 2px solid transparent;
    border-radius: 8px;
    overflow: hidden;
    cursor: pointer;
    transition: border-color 0.3s ease;
  }

  .ai-thumbnail-{{ ai_gen_id }}:hover,
  .ai-thumbnail-{{ ai_gen_id }}.active {
    border-color: {{ block.settings.accent_color }};
  }

  .ai-thumbnail-{{ ai_gen_id }} img {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }

  .ai-3d-button-{{ ai_gen_id }} {
    width: 80px;
    height: 40px;
    background-color: {{ block.settings.accent_color }};
    color: white;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-size: 12px;
    font-weight: 600;
    transition: background-color 0.3s ease;
  }

  .ai-3d-button-{{ ai_gen_id }}:hover {
    background-color: {{ block.settings.accent_color | color_darken: 10 }};
  }

  .ai-3d-button-{{ ai_gen_id }}.active {
    background-color: {{ block.settings.accent_color | color_darken: 20 }};
  }

  .ai-main-container-{{ ai_gen_id }} {
    width: 400px;
    height: 400px;
    position: relative;
    background-color: {{ block.settings.container_bg_color }};
    border-radius: {{ block.settings.container_border_radius }}px;
    overflow: hidden;
    flex-shrink: 0;
  }

  .ai-2d-viewer-{{ ai_gen_id }} {
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    position: absolute;
    top: 0;
    left: 0;
  }

  .ai-2d-viewer-{{ ai_gen_id }} img {
    max-width: 90%;
    max-height: 90%;
    object-fit: contain;
    border-radius: 8px;
  }

  .ai-3d-container-{{ ai_gen_id }} {
    width: 100%;
    height: 100%;
    position: absolute;
    top: 0;
    left: 0;
    display: none;
  }

  .ai-3d-container-{{ ai_gen_id }}.active {
    display: block;
  }

  .ai-3d-canvas-{{ ai_gen_id }} {
    width: 100%;
    height: 100%;
    display: block;
    cursor: grab;
  }

  .ai-3d-canvas-{{ ai_gen_id }}:active {
    cursor: grabbing;
  }

  .ai-product-info-{{ ai_gen_id }} {
    flex: 1;
    min-width: 250px;
    padding-left: 20px;
  }

  .ai-product-title-{{ ai_gen_id }} {
    font-size: 24px;
    font-weight: 600;
    margin: 0 0 10px 0;
    color: {{ block.settings.text_color }};
  }

  .ai-product-price-{{ ai_gen_id }} {
    font-size: 20px;
    font-weight: 500;
    margin: 0 0 20px 0;
    color: {{ block.settings.accent_color }};
  }

  .ai-product-description-{{ ai_gen_id }} {
    font-size: 14px;
    line-height: 1.5;
    margin: 0 0 20px 0;
    color: {{ block.settings.text_color }};
  }

  .ai-variant-section-{{ ai_gen_id }} {
    margin-bottom: 20px;
  }

  .ai-variant-label-{{ ai_gen_id }} {
    font-size: 14px;
    font-weight: 600;
    margin-bottom: 8px;
    color: {{ block.settings.text_color }};
  }

  .ai-variant-options-{{ ai_gen_id }} {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
  }

  .ai-variant-button-{{ ai_gen_id }} {
    padding: 8px 16px;
    border: 2px solid {{ block.settings.variant_border_color }};
    background-color: transparent;
    color: {{ block.settings.text_color }};
    border-radius: 6px;
    cursor: pointer;
    font-size: 14px;
    transition: all 0.3s ease;
    white-space: nowrap;
  }

  .ai-variant-button-{{ ai_gen_id }}:hover {
    border-color: {{ block.settings.accent_color }};
    background-color: {{ block.settings.accent_color | color_modify: 'alpha', 0.1 }};
  }

  .ai-variant-button-{{ ai_gen_id }}.selected {
    border-color: {{ block.settings.accent_color }};
    background-color: {{ block.settings.accent_color }};
    color: white;
  }

  @media screen and (max-width: 768px) {
    .ai-product-viewer-{{ ai_gen_id }} {
      flex-direction: column;
      gap: 15px;
      padding: 15px;
    }

    .ai-thumbnail-column-{{ ai_gen_id }} {
      flex-direction: row;
      width: 100%;
      overflow-x: auto;
      padding-bottom: 5px;
    }

    .ai-thumbnail-column-{{ ai_gen_id }}::-webkit-scrollbar {
      height: 4px;
    }

    .ai-thumbnail-column-{{ ai_gen_id }}::-webkit-scrollbar-track {
      background: #f1f1f1;
      border-radius: 2px;
    }

    .ai-thumbnail-column-{{ ai_gen_id }}::-webkit-scrollbar-thumb {
      background: {{ block.settings.accent_color }};
      border-radius: 2px;
    }

    .ai-main-container-{{ ai_gen_id }} {
      width: 100%;
      height: 300px;
      aspect-ratio: 1;
    }

    .ai-product-info-{{ ai_gen_id }} {
      padding-left: 0;
    }

    .ai-variant-options-{{ ai_gen_id }} {
      justify-content: flex-start;
    }
  }

  @media screen and (max-width: 480px) {
    .ai-main-container-{{ ai_gen_id }} {
      height: 250px;
    }

    .ai-product-title-{{ ai_gen_id }} {
      font-size: 20px;
    }

    .ai-product-price-{{ ai_gen_id }} {
      font-size: 18px;
    }
  }
{% endstyle %}

<product-3d-viewer-{{ ai_gen_id }}
  class="ai-product-viewer-{{ ai_gen_id }}"
  {{ block.shopify_attributes }}
>
  <div class="ai-thumbnail-column-{{ ai_gen_id }}">
    {% liquid
      if product
        assign current_product = product
      elsif block.settings.product
        assign current_product = block.settings.product
      else
        assign current_product = null
      endif
    %}

    {% if current_product and current_product.images.size > 1 %}
      {% for image in current_product.images limit: current_product.images.size %}
        {% unless forloop.last %}
          <div
            class="ai-thumbnail-{{ ai_gen_id }}"
            data-image-index="{{ forloop.index0 }}"
            data-image-url="{{ image | image_url: width: 800 }}"
          >
            <img
              src="{{ image | image_url: width: 100 }}"
              alt="{{ image.alt | escape }}"
              loading="lazy"
            >
          </div>
        {% endunless %}
      {% endfor %}
    {% endif %}

    <button class="ai-3d-button-{{ ai_gen_id }}" data-mode="3d">
      3D View
    </button>
  </div>

  <div class="ai-main-container-{{ ai_gen_id }}">
    <div class="ai-2d-viewer-{{ ai_gen_id }}">
      {% if current_product and current_product.images.size > 0 %}
        <img
          id="ai-main-image-{{ ai_gen_id }}"
          src="{{ current_product.images.first | image_url: width: 800 }}"
          alt="{{ current_product.images.first.alt | escape }}"
          loading="lazy"
        >
      {% else %}
        <div style="color: #999; text-align: center;">
          <p>No product images available</p>
        </div>
      {% endif %}
    </div>

    <div class="ai-3d-container-{{ ai_gen_id }}">
      <canvas class="ai-3d-canvas-{{ ai_gen_id }}"></canvas>
    </div>
  </div>

  <div class="ai-product-info-{{ ai_gen_id }}">
    {% if current_product %}
      <h2 class="ai-product-title-{{ ai_gen_id }}">{{ current_product.title }}</h2>
      <div class="ai-product-price-{{ ai_gen_id }}">{{ current_product.price | money }}</div>
      
      {% if current_product.description != blank %}
        <div class="ai-product-description-{{ ai_gen_id }}">
          {{ current_product.description | truncate: 150 }}
        </div>
      {% endif %}

      {% for option in current_product.options_with_values %}
        <div class="ai-variant-section-{{ ai_gen_id }}">
          <div class="ai-variant-label-{{ ai_gen_id }}">{{ option.name }}:</div>
          <div class="ai-variant-options-{{ ai_gen_id }}">
            {% for value in option.values %}
              <button
                class="ai-variant-button-{{ ai_gen_id }}"
                data-option-name="{{ option.name | downcase }}"
                data-option-value="{{ value }}"
                {% if forloop.first %}data-selected="true"{% endif %}
              >
                {{ value }}
              </button>
            {% endfor %}
          </div>
        </div>
      {% endfor %}
    {% else %}
      <h2 class="ai-product-title-{{ ai_gen_id }}">Product Preview</h2>
      <div class="ai-product-price-{{ ai_gen_id }}">Select a product to view details</div>
    {% endif %}
  </div>
</product-3d-viewer-{{ ai_gen_id }}>

<script>
  (function() {
    class Product3DViewer{{ ai_gen_id }} extends HTMLElement {
      constructor() {
        super();
        this.currentMode = '2d';
        this.canvas = null;
        this.gl = null;
        this.program = null;
        this.rotationX = -0.3;
        this.rotationY = 0;
        this.isDragging = false;
        this.lastMouseX = 0;
        this.lastMouseY = 0;
        this.posterTexture = null;
        this.currentFinish = 'matte';
        this.currentMaterial = 'metal';
      }

      connectedCallback() {
        this.setupEventListeners();
        this.initializeVariants();
      }

      setupEventListeners() {
        const thumbnails = this.querySelectorAll('.ai-thumbnail-{{ ai_gen_id }}');
        const button3D = this.querySelector('.ai-3d-button-{{ ai_gen_id }}');
        const mainImage = this.querySelector('#ai-main-image-{{ ai_gen_id }}');
        const viewer2D = this.querySelector('.ai-2d-viewer-{{ ai_gen_id }}');
        const container3D = this.querySelector('.ai-3d-container-{{ ai_gen_id }}');

        thumbnails.forEach(thumbnail => {
          thumbnail.addEventListener('click', () => {
            const imageUrl = thumbnail.dataset.imageUrl;
            if (mainImage && imageUrl) {
              mainImage.src = imageUrl;
            }
            
            thumbnails.forEach(t => t.classList.remove('active'));
            thumbnail.classList.add('active');
            
            if (this.currentMode === '2d') {
              viewer2D.style.display = 'flex';
              container3D.classList.remove('active');
            }
          });
        });

        if (button3D) {
          button3D.addEventListener('click', () => {
            if (this.currentMode === '2d') {
              this.currentMode = '3d';
              button3D.textContent = '2D View';
              button3D.classList.add('active');
              viewer2D.style.display = 'none';
              container3D.classList.add('active');
              this.init3D();
            } else {
              this.currentMode = '2d';
              button3D.textContent = '3D View';
              button3D.classList.remove('active');
              viewer2D.style.display = 'flex';
              container3D.classList.remove('active');
            }
          });
        }

        const variantButtons = this.querySelectorAll('.ai-variant-button-{{ ai_gen_id }}');
        variantButtons.forEach(button => {
          button.addEventListener('click', () => {
            const optionName = button.dataset.optionName;
            const optionValue = button.dataset.optionValue;
            
            const sameOptionButtons = this.querySelectorAll(`[data-option-name="${optionName}"]`);
            sameOptionButtons.forEach(btn => {
              btn.classList.remove('selected');
              btn.removeAttribute('data-selected');
            });
            
            button.classList.add('selected');
            button.setAttribute('data-selected', 'true');

            if (optionName === 'material') {
              if (optionValue.toLowerCase().includes('acrylic')) {
                this.currentFinish = 'glossy';
                this.currentMaterial = 'acrylic';
              } else if (optionValue.toLowerCase().includes('metal')) {
                this.currentFinish = 'matte';
                this.currentMaterial = 'metal';
              }
              
              if (this.currentMode === '3d' && this.gl) {
                this.setupGeometry();
                this.render();
              }
            }
          });
        });
      }

      initializeVariants() {
        const variantButtons = this.querySelectorAll('.ai-variant-button-{{ ai_gen_id }}[data-selected="true"]');
        variantButtons.forEach(button => {
          button.classList.add('selected');
          
          const optionName = button.dataset.optionName;
          const optionValue = button.dataset.optionValue;
          
          if (optionName === 'material') {
            if (optionValue.toLowerCase().includes('acrylic')) {
              this.currentFinish = 'glossy';
              this.currentMaterial = 'acrylic';
            } else if (optionValue.toLowerCase().includes('metal')) {
              this.currentFinish = 'matte';
              this.currentMaterial = 'metal';
            }
          }
        });
      }

      init3D() {
        this.canvas = this.querySelector('.ai-3d-canvas-{{ ai_gen_id }}');
        if (!this.canvas) return;

        this.gl = this.canvas.getContext('webgl') || this.canvas.getContext('experimental-webgl');
        if (!this.gl) {
          console.error('WebGL not supported');
          return;
        }

        this.canvas.width = this.canvas.offsetWidth;
        this.canvas.height = this.canvas.offsetHeight;
        this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);

        this.setupShaders();
        this.setupGeometry();
        this.loadTexture();
        this.setupControls();
        this.render();
      }

      setupShaders() {
        const vertexShaderSource = `
          attribute vec3 a_position;
          attribute vec2 a_texCoord;
          attribute vec3 a_normal;
          attribute float a_alpha;
          
          uniform mat4 u_modelViewMatrix;
          uniform mat4 u_projectionMatrix;
          uniform mat3 u_normalMatrix;
          
          varying vec2 v_texCoord;
          varying vec3 v_normal;
          varying vec3 v_position;
          varying float v_alpha;
          
          void main() {
            gl_Position = u_projectionMatrix * u_modelViewMatrix * vec4(a_position, 1.0);
            v_texCoord = a_texCoord;
            v_normal = u_normalMatrix * a_normal;
            v_position = (u_modelViewMatrix * vec4(a_position, 1.0)).xyz;
            v_alpha = a_alpha;
          }
        `;

        const fragmentShaderSource = `
          precision mediump float;
          
          uniform sampler2D u_texture;
          uniform float u_finish;
          uniform vec3 u_keyLightDir;
          uniform vec3 u_fillLightDir;
          uniform vec3 u_backLightDir;
          uniform vec3 u_keyLightColor;
          uniform vec3 u_fillLightColor;
          uniform vec3 u_backLightColor;
          uniform float u_keyLightIntensity;
          uniform float u_fillLightIntensity;
          uniform float u_backLightIntensity;
          uniform bool u_isGlossLayer;
          
          varying vec2 v_texCoord;
          varying vec3 v_normal;
          varying vec3 v_position;
          varying float v_alpha;
          
          void main() {
            vec4 texColor;
            
            if (u_isGlossLayer) {
              texColor = vec4(1.0, 1.0, 1.0, 0.3);
            } else {
              texColor = texture2D(u_texture, v_texCoord);
            }
            
            vec3 normal = normalize(v_normal);
            vec3 viewDir = normalize(-v_position);
            
            vec3 keyLightDir = normalize(-u_keyLightDir);
            vec3 fillLightDir = normalize(-u_fillLightDir);
            vec3 backLightDir = normalize(-u_backLightDir);
            
            float keyDiffuse = max(dot(normal, keyLightDir), 0.0);
            float fillDiffuse = max(dot(normal, fillLightDir), 0.0);
            float backDiffuse = max(dot(normal, backLightDir), 0.0);
            
            vec3 keyReflectDir = reflect(-keyLightDir, normal);
            vec3 fillReflectDir = reflect(-fillLightDir, normal);
            vec3 backReflectDir = reflect(-backLightDir, normal);
            
            float shininess = u_finish > 0.5 ? 256.0 : 32.0;
            float specularStrength = u_finish > 0.5 ? 1.5 : 0.4;
            
            float keySpecular = pow(max(dot(viewDir, keyReflectDir), 0.0), shininess);
            float fillSpecular = pow(max(dot(viewDir, fillReflectDir), 0.0), shininess * 0.5);
            float backSpecular = pow(max(dot(viewDir, backReflectDir), 0.0), shininess * 0.3);
            
            vec3 keyContribution = u_keyLightColor * u_keyLightIntensity * (keyDiffuse + keySpecular * specularStrength);
            vec3 fillContribution = u_fillLightColor * u_fillLightIntensity * (fillDiffuse + fillSpecular * specularStrength * 0.3);
            vec3 backContribution = u_backLightColor * u_backLightIntensity * (backDiffuse + backSpecular * specularStrength * 0.2);
            
            vec3 ambient = vec3(0.4);
            vec3 totalLighting = ambient + keyContribution + fillContribution + backContribution;
            
            totalLighting = clamp(totalLighting, 0.4, 2.5);
            
            gl_FragColor = vec4(texColor.rgb * totalLighting, texColor.a * v_alpha);
          }
        `;

        const vertexShader = this.createShader(this.gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = this.createShader(this.gl.FRAGMENT_SHADER, fragmentShaderSource);

        this.program = this.gl.createProgram();
        this.gl.attachShader(this.program, vertexShader);
        this.gl.attachShader(this.program, fragmentShader);
        this.gl.linkProgram(this.program);

        if (!this.gl.getProgramParameter(this.program, this.gl.LINK_STATUS)) {
          console.error('Program linking failed:', this.gl.getProgramInfoLog(this.program));
        }
      }

      createShader(type, source) {
        const shader = this.gl.createShader(type);
        this.gl.shaderSource(shader, source);
        this.gl.compileShader(shader);

        if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
          console.error('Shader compilation failed:', this.gl.getShaderInfoLog(shader));
          this.gl.deleteShader(shader);
          return null;
        }

        return shader;
      }

      setupGeometry() {
        const posterWidth = 1.0;
        const posterHeight = 1.5;
        const posterDepth = this.currentMaterial === 'acrylic' ? 0.03 : 0.01;

        const vertices = [];
        const texCoords = [];
        const normals = [];
        const alphas = [];
        const indices = [];

        let vertexIndex = 0;

        const addFace = (v1, v2, v3, v4, normal, texCoord, alpha = 1.0) => {
          vertices.push(...v1, ...v2, ...v3, ...v4);
          texCoords.push(...texCoord);
          normals.push(...normal, ...normal, ...normal, ...normal);
          alphas.push(alpha, alpha, alpha, alpha);
          
          indices.push(
            vertexIndex, vertexIndex + 1, vertexIndex + 2,
            vertexIndex, vertexIndex + 2, vertexIndex + 3
          );
          vertexIndex += 4;
        };

        addFace(
          [-posterWidth/2, -posterHeight/2, posterDepth/2],
          [posterWidth/2, -posterHeight/2, posterDepth/2],
          [posterWidth/2, posterHeight/2, posterDepth/2],
          [-posterWidth/2, posterHeight/2, posterDepth/2],
          [0, 0, 1],
          [0, 0, 1, 0, 1, 1, 0, 1]
        );

        addFace(
          [-posterWidth/2, -posterHeight/2, -posterDepth/2],
          [-posterWidth/2, posterHeight/2, -posterDepth/2],
          [posterWidth/2, posterHeight/2, -posterDepth/2],
          [posterWidth/2, -posterHeight/2, -posterDepth/2],
          [0, 0, -1],
          [1, 0, 1, 1, 0, 1, 0, 0]
        );

        addFace(
          [-posterWidth/2, posterHeight/2, -posterDepth/2],
          [-posterWidth/2, posterHeight/2, posterDepth/2],
          [posterWidth/2, posterHeight/2, posterDepth/2],
          [posterWidth/2, posterHeight/2, -posterDepth/2],
          [0, 1, 0],
          [0, 1, 0, 0, 1, 0, 1, 1]
        );

        addFace(
          [-posterWidth/2, -posterHeight/2, -posterDepth/2],
          [posterWidth/2, -posterHeight/2, -posterDepth/2],
          [posterWidth/2, -posterHeight/2, posterDepth/2],
          [-posterWidth/2, -posterHeight/2, posterDepth/2],
          [0, -1, 0],
          [1, 1, 0, 1, 0, 0, 1, 0]
        );

        addFace(
          [posterWidth/2, -posterHeight/2, -posterDepth/2],
          [posterWidth/2, posterHeight/2, -posterDepth/2],
          [posterWidth/2, posterHeight/2, posterDepth/2],
          [posterWidth/2, -posterHeight/2, posterDepth/2],
          [1, 0, 0],
          [1, 0, 1, 1, 0, 1, 0, 0]
        );

        addFace(
          [-posterWidth/2, -posterHeight/2, -posterDepth/2],
          [-posterWidth/2, -posterHeight/2, posterDepth/2],
          [-posterWidth/2, posterHeight/2, posterDepth/2],
          [-posterWidth/2, posterHeight/2, -posterDepth/2],
          [-1, 0, 0],
          [0, 0, 1, 0, 1, 1, 0, 1]
        );

        if (this.currentMaterial === 'acrylic') {
          const glossOffset = 0.001;
          addFace(
            [-posterWidth/2, -posterHeight/2, posterDepth/2 + glossOffset],
            [posterWidth/2, -posterHeight/2, posterDepth/2 + glossOffset],
            [posterWidth/2, posterHeight/2, posterDepth/2 + glossOffset],
            [-posterWidth/2, posterHeight/2, posterDepth/2 + glossOffset],
            [0, 0, 1],
            [0, 0, 1, 0, 1, 1, 0, 1],
            0.3
          );
        }

        this.positionBuffer = this.gl.createBuffer();
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vertices), this.gl.STATIC_DRAW);

        this.texCoordBuffer = this.gl.createBuffer();
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.texCoordBuffer);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(texCoords), this.gl.STATIC_DRAW);

        this.normalBuffer = this.gl.createBuffer();
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.normalBuffer);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(normals), this.gl.STATIC_DRAW);

        this.alphaBuffer = this.gl.createBuffer();
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.alphaBuffer);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(alphas), this.gl.STATIC_DRAW);

        this.indexBuffer = this.gl.createBuffer();
        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), this.gl.STATIC_DRAW);

        this.indexCount = indices.length;
      }

      loadTexture() {
        const mainImage = this.querySelector('#ai-main-image-{{ ai_gen_id }}');
        if (!mainImage || !mainImage.src) return;

        this.posterTexture = this.gl.createTexture();
        this.gl.bindTexture(this.gl.TEXTURE_2D, this.posterTexture);

        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, 1, 1, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, new Uint8Array([255, 255, 255, 255]));

        const image = new Image();
        image.crossOrigin = 'anonymous';
        image.onload = () => {
          this.gl.bindTexture(this.gl.TEXTURE_2D, this.posterTexture);
          this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, image);
          this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
          this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
          this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
          this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
          this.render();
        };
        image.src = mainImage.src;
      }

      setupControls() {
        this.canvas.addEventListener('mousedown', (e) => {
          this.isDragging = true;
          this.lastMouseX = e.clientX;
          this.lastMouseY = e.clientY;
        });

        this.canvas.addEventListener('mousemove', (e) => {
          if (!this.isDragging) return;

          const deltaX = e.clientX - this.lastMouseX;
          const deltaY = e.clientY - this.lastMouseY;

          this.rotationY += deltaX * 0.01;
          this.rotationX += deltaY * 0.01;

          this.rotationX = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.rotationX));

          this.lastMouseX = e.clientX;
          this.lastMouseY = e.clientY;

          this.render();
        });

        this.canvas.addEventListener('mouseup', () => {
          this.isDragging = false;
        });

        this.canvas.addEventListener('touchstart', (e) => {
          e.preventDefault();
          const touch = e.touches[0];
          this.isDragging = true;
          this.lastMouseX = touch.clientX;
          this.lastMouseY = touch.clientY;
        });

        this.canvas.addEventListener('touchmove', (e) => {
          e.preventDefault();
          if (!this.isDragging) return;

          const touch = e.touches[0];
          const deltaX = touch.clientX - this.lastMouseX;
          const deltaY = touch.clientY - this.lastMouseY;

          this.rotationY += deltaX * 0.01;
          this.rotationX += deltaY * 0.01;

          this.rotationX = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.rotationX));

          this.lastMouseX = touch.clientX;
          this.lastMouseY = touch.clientY;

          this.render();
        });

        this.canvas.addEventListener('touchend', (e) => {
          e.preventDefault();
          this.isDragging = false;
        });
      }

      render() {
        if (!this.gl || !this.program) return;

        this.gl.clearColor(0.98, 0.98, 0.98, 1.0);
        this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
        this.gl.enable(this.gl.DEPTH_TEST);
        this.gl.enable(this.gl.BLEND);
        this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);

        this.gl.useProgram(this.program);

        const projectionMatrix = this.createPerspectiveMatrix(45 * Math.PI / 180, this.canvas.width / this.canvas.height, 0.1, 100.0);
        const modelViewMatrix = this.createModelViewMatrix();
        const normalMatrix = this.createNormalMatrix(modelViewMatrix);

        const projectionLocation = this.gl.getUniformLocation(this.program, 'u_projectionMatrix');
        const modelViewLocation = this.gl.getUniformLocation(this.program, 'u_modelViewMatrix');
        const normalLocation = this.gl.getUniformLocation(this.program, 'u_normalMatrix');
        const textureLocation = this.gl.getUniformLocation(this.program, 'u_texture');
        const finishLocation = this.gl.getUniformLocation(this.program, 'u_finish');
        const isGlossLayerLocation = this.gl.getUniformLocation(this.program, 'u_isGlossLayer');

        const keyLightDirLocation = this.gl.getUniformLocation(this.program, 'u_keyLightDir');
        const fillLightDirLocation = this.gl.getUniformLocation(this.program, 'u_fillLightDir');
        const backLightDirLocation = this.gl.getUniformLocation(this.program, 'u_backLightDir');
        const keyLightColorLocation = this.gl.getUniformLocation(this.program, 'u_keyLightColor');
        const fillLightColorLocation = this.gl.getUniformLocation(this.program, 'u_fillLightColor');
        const backLightColorLocation = this.gl.getUniformLocation(this.program, 'u_backLightColor');
        const keyLightIntensityLocation = this.gl.getUniformLocation(this.program, 'u_keyLightIntensity');
        const fillLightIntensityLocation = this.gl.getUniformLocation(this.program, 'u_fillLightIntensity');
        const backLightIntensityLocation = this.gl.getUniformLocation(this.program, 'u_backLightIntensity');

        this.gl.uniformMatrix4fv(projectionLocation, false, projectionMatrix);
        this.gl.uniformMatrix4fv(modelViewLocation, false, modelViewMatrix);
        this.gl.uniformMatrix3fv(normalLocation, false, normalMatrix);
        this.gl.uniform1f(finishLocation, this.currentFinish === 'glossy' ? 1.0 : 0.0);

        this.gl.uniform3fv(keyLightDirLocation, [1.2, 1.5, 2.5]);
        this.gl.uniform3fv(fillLightDirLocation, [-1.0, 0.8, 2.0]);
        this.gl.uniform3fv(backLightDirLocation, [-0.5, -1.0, -1.5]);
        
        this.gl.uniform3fv(keyLightColorLocation, [1.0, 0.98, 0.95]);
        this.gl.uniform3fv(fillLightColorLocation, [0.85, 0.9, 1.0]);
        this.gl.uniform3fv(backLightColorLocation, [0.95, 0.95, 0.85]);
        
        this.gl.uniform1f(keyLightIntensityLocation, 1.2);
        this.gl.uniform1f(fillLightIntensityLocation, 0.6);
        this.gl.uniform1f(backLightIntensityLocation, 0.4);

        const positionLocation = this.gl.getAttribLocation(this.program, 'a_position');
        const texCoordLocation = this.gl.getAttribLocation(this.program, 'a_texCoord');
        const normalLocation2 = this.gl.getAttribLocation(this.program, 'a_normal');
        const alphaLocation = this.gl.getAttribLocation(this.program, 'a_alpha');

        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
        this.gl.enableVertexAttribArray(positionLocation);
        this.gl.vertexAttribPointer(positionLocation, 3, this.gl.FLOAT, false, 0, 0);

        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.texCoordBuffer);
        this.gl.enableVertexAttribArray(texCoordLocation);
        this.gl.vertexAttribPointer(texCoordLocation, 2, this.gl.FLOAT, false, 0, 0);

        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.normalBuffer);
        this.gl.enableVertexAttribArray(normalLocation2);
        this.gl.vertexAttribPointer(normalLocation2, 3, this.gl.FLOAT, false, 0, 0);

        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.alphaBuffer);
        this.gl.enableVertexAttribArray(alphaLocation);
        this.gl.vertexAttribPointer(alphaLocation, 1, this.gl.FLOAT, false, 0, 0);

        this.gl.activeTexture(this.gl.TEXTURE0);
        this.gl.bindTexture(this.gl.TEXTURE_2D, this.posterTexture);
        this.gl.uniform1i(textureLocation, 0);

        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);

        const baseTriangles = this.currentMaterial === 'acrylic' ? 36 : 36;
        const glossTriangles = this.currentMaterial === 'acrylic' ? 6 : 0;

        this.gl.uniform1i(isGlossLayerLocation, 0);
        this.gl.drawElements(this.gl.TRIANGLES, baseTriangles, this.gl.UNSIGNED_SHORT, 0);

        if (glossTriangles > 0) {
          this.gl.uniform1i(isGlossLayerLocation, 1);
          this.gl.drawElements(this.gl.TRIANGLES, glossTriangles, this.gl.UNSIGNED_SHORT, baseTriangles * 2);
        }
      }

      createPerspectiveMatrix(fov, aspect, near, far) {
        const f = Math.tan(Math.PI * 0.5 - 0.5 * fov);
        const rangeInv = 1.0 / (near - far);

        return [
          f / aspect, 0, 0, 0,
          0, f, 0, 0,
          0, 0, (near + far) * rangeInv, -1,
          0, 0, near * far * rangeInv * 2, 0
        ];
      }

      createModelViewMatrix() {
        const matrix = [
          1, 0, 0, 0,
          0, 1, 0, 0,
          0, 0, 1, 0,
          0, 0, -3, 1
        ];

        this.rotateX(matrix, this.rotationX);
        this.rotateY(matrix, this.rotationY);

        return matrix;
      }

      createNormalMatrix(modelViewMatrix) {
        const a00 = modelViewMatrix[0], a01 = modelViewMatrix[1], a02 = modelViewMatrix[2];
        const a10 = modelViewMatrix[4], a11 = modelViewMatrix[5], a12 = modelViewMatrix[6];
        const a20 = modelViewMatrix[8], a21 = modelViewMatrix[9], a22 = modelViewMatrix[10];

        const b01 = a22 * a11 - a12 * a21;
        const b11 = -a22 * a10 + a12 * a20;
        const b21 = a21 * a10 - a11 * a20;

        const det = a00 * b01 + a01 * b11 + a02 * b21;
        if (!det) return null;

        const detInv = 1.0 / det;

        return [
          b01 * detInv,
          (-a22 * a01 + a02 * a21) * detInv,
          (a12 * a01 - a02 * a11) * detInv,
          b11 * detInv,
          (a22 * a00 - a02 * a20) * detInv,
          (-a12 * a00 + a02 * a10) * detInv,
          b21 * detInv,
          (-a21 * a00 + a01 * a20) * detInv,
          (a11 * a00 - a01 * a10) * detInv
        ];
      }

      rotateX(matrix, angle) {
        const c = Math.cos(angle);
        const s = Math.sin(angle);
        const mv1 = matrix[1], mv5 = matrix[5], mv9 = matrix[9];

        matrix[1] = matrix[1] * c - matrix[2] * s;
        matrix[5] = matrix[5] * c - matrix[6] * s;
        matrix[9] = matrix[9] * c - matrix[10] * s;

        matrix[2] = matrix[2] * c + mv1 * s;
        matrix[6] = matrix[6] * c + mv5 * s;
        matrix[10] = matrix[10] * c + mv9 * s;
      }

      rotateY(matrix, angle) {
        const c = Math.cos(angle);
        const s = Math.sin(angle);
        const mv0 = matrix[0], mv4 = matrix[4], mv8 = matrix[8];

        matrix[0] = c * matrix[0] + s * matrix[2];
        matrix[4] = c * matrix[4] + s * matrix[6];
        matrix[8] = c * matrix[8] + s * matrix[10];

        matrix[2] = c * matrix[2] - s * mv0;
        matrix[6] = c * matrix[6] - s * mv4;
        matrix[10] = c * matrix[10] - s * mv8;
      }
    }

    customElements.define('product-3d-viewer-{{ ai_gen_id }}', Product3DViewer{{ ai_gen_id }});
  })();
</script>

{% schema %}
{
  "name": "3D Product Viewer",
  "tag": null,
  "settings": [
    {
      "type": "header",
      "content": "Product"
    },
    {
      "type": "product",
      "id": "product",
      "label": "Product"
    },
    {
      "type": "header",
      "content": "Colors"
    },
    {
      "type": "color",
      "id": "container_bg_color",
      "label": "Container background",
      "default": "#f8f8f8"
    },
    {
      "type": "color",
      "id": "accent_color",
      "label": "Accent color",
      "default": "#000000"
    },
    {
      "type": "color",
      "id": "text_color",
      "label": "Text color",
      "default": "#333333"
    },
    {
      "type": "color",
      "id": "variant_border_color",
      "label": "Variant border color",
      "default": "#cccccc"
    },
    {
      "type": "header",
      "content": "Style"
    },
    {
      "type": "range",
      "id": "container_border_radius",
      "min": 0,
      "max": 20,
      "step": 2,
      "unit": "px",
      "label": "Container border radius",
      "default": 12
    }
  ],
  "presets": [
    {
      "name": "3D Product Viewer"
    }
  ]
}
{% endschema %}